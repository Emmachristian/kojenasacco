# loans/services.py

"""
Loans Business Logic Services

Contains complex business logic that shouldn't be in views or models:
- Loan application processing workflows
- Loan disbursement and approval
- Payment processing and allocation
- Interest accrual and penalties
- Loan restructuring
- Schedule management
- Guarantor and collateral management
- Bulk operations

WHY SERVICES.PY?
1. Separation of Concerns: Complex business logic separate from views
2. Reusability: Can be called from views, management commands, celery tasks
3. Testing: Easier to test business logic in isolation
4. Transaction Management: Handle complex multi-step operations
5. Clear API: Well-defined functions for each business operation
"""

from django.db import transaction
from django.utils import timezone
from decimal import Decimal
from datetime import timedelta
import logging

from .models import (
    LoanProduct,
    LoanApplication,
    Loan,
    LoanPayment,
    LoanSchedule,
    LoanGuarantor,
    LoanCollateral,
    LoanDocument,
)

from .utils import (
    validate_loan_amount,
    validate_loan_term,
    validate_member_loan_eligibility,
    can_approve_loan_application,
    can_disburse_loan,
    calculate_flat_interest,
    calculate_reducing_balance_interest,
    calculate_monthly_emi,
    calculate_total_repayment,
    generate_loan_schedule,
    allocate_payment,
    calculate_late_payment_penalty,
    calculate_early_repayment_penalty,
    is_loan_overdue,
)

logger = logging.getLogger(__name__)


# =============================================================================
# LOAN APPLICATION SERVICES
# =============================================================================

class LoanApplicationService:
    """Handle loan application lifecycle and processing"""
    
    @staticmethod
    @transaction.atomic
    def create_application(member, loan_product, amount_requested, term_months,
                          purpose, disbursement_method=None, disbursement_account=None):
        """
        Create a new loan application.
        
        Args:
            member: Member instance
            loan_product: LoanProduct instance
            amount_requested (Decimal): Requested loan amount
            term_months (int): Requested loan term in months
            purpose (str): Purpose of the loan
            disbursement_method (str, optional): How to disburse the loan
            disbursement_account (str, optional): Account for disbursement
        
        Returns:
            tuple: (success: bool, application_or_error_message)
        
        Example:
            >>> success, app = LoanApplicationService.create_application(
            ...     member=member,
            ...     loan_product=product,
            ...     amount_requested=Decimal('100000'),
            ...     term_months=12,
            ...     purpose="Business expansion"
            ... )
        """
        # Validate amount
        is_valid, message = validate_loan_amount(amount_requested, loan_product)
        if not is_valid:
            return False, message
        
        # Validate term
        is_valid, message = validate_loan_term(term_months, loan_product)
        if not is_valid:
            return False, message
        
        # Validate member eligibility
        is_eligible, message = validate_member_loan_eligibility(member, loan_product)
        if not is_eligible:
            return False, message
        
        try:
            # Create application (number and fees auto-generated by signals)
            application = LoanApplication.objects.create(
                member=member,
                loan_product=loan_product,
                amount_requested=amount_requested,
                term_months=term_months,
                purpose=purpose,
                disbursement_method=disbursement_method,
                disbursement_account=disbursement_account,
                status='DRAFT'
            )
            
            logger.info(
                f"Created loan application {application.application_number} | "
                f"Member: {member.get_full_name()} | "
                f"Amount: {amount_requested}"
            )
            
            return True, application
            
        except Exception as e:
            logger.error(f"Error creating loan application: {e}", exc_info=True)
            return False, f"Error creating application: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def submit_application(application, submitted_by=None):
        """
        Submit application for review.
        
        Args:
            application: LoanApplication instance
            submitted_by: User who submitted the application
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if application.status != 'DRAFT':
            return False, f"Cannot submit application with status: {application.get_status_display()}"
        
        try:
            # Use model method
            success, message = application.submit()
            
            if success:
                logger.info(
                    f"Application {application.application_number} submitted by "
                    f"{submitted_by if submitted_by else 'member'}"
                )
            
            return success, message
            
        except Exception as e:
            logger.error(f"Error submitting application: {e}", exc_info=True)
            return False, f"Error submitting application: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def review_application(application, reviewed_by):
        """
        Mark application as under review.
        
        Args:
            application: LoanApplication instance
            reviewed_by: User reviewing the application
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if application.status != 'SUBMITTED':
            return False, "Only submitted applications can be reviewed"
        
        try:
            application.status = 'UNDER_REVIEW'
            application.reviewed_date = timezone.now()
            application.reviewed_by_id = str(reviewed_by.id) if reviewed_by else None
            application.save(update_fields=['status', 'reviewed_date', 'reviewed_by_id', 'updated_at'])
            
            logger.info(
                f"Application {application.application_number} under review by "
                f"{reviewed_by if reviewed_by else 'system'}"
            )
            
            return True, "Application marked as under review"
            
        except Exception as e:
            logger.error(f"Error reviewing application: {e}", exc_info=True)
            return False, f"Error reviewing application: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def approve_application(application, approved_amount=None, approved_term=None,
                           approved_rate=None, approved_by=None):
        """
        Approve loan application.
        
        Args:
            application: LoanApplication instance
            approved_amount (Decimal, optional): Final approved amount
            approved_term (int, optional): Final approved term
            approved_rate (Decimal, optional): Final approved interest rate
            approved_by: User who approved the application
        
        Returns:
            tuple: (success: bool, message: str)
        """
        # Check if can be approved
        can_approve, message = can_approve_loan_application(application)
        if not can_approve:
            return False, message
        
        try:
            # Use model method
            success, message = application.approve(
                approved_amount=approved_amount,
                approved_term=approved_term,
                approved_rate=approved_rate
            )
            
            if success:
                # Update approved_by
                application.approved_by_id = str(approved_by.id) if approved_by else None
                application.save(update_fields=['approved_by_id'])
                
                logger.info(
                    f"Application {application.application_number} approved | "
                    f"Amount: {application.approved_amount} | "
                    f"Term: {application.approved_term} months | "
                    f"By: {approved_by if approved_by else 'system'}"
                )
            
            return success, message
            
        except Exception as e:
            logger.error(f"Error approving application: {e}", exc_info=True)
            return False, f"Error approving application: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def reject_application(application, reason, rejected_by=None):
        """
        Reject loan application.
        
        Args:
            application: LoanApplication instance
            reason (str): Reason for rejection
            rejected_by: User who rejected the application
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if not reason:
            return False, "Rejection reason is required"
        
        try:
            # Use model method
            success, message = application.reject(reason)
            
            if success:
                # Update reviewed_by
                application.reviewed_by_id = str(rejected_by.id) if rejected_by else None
                application.save(update_fields=['reviewed_by_id'])
                
                logger.info(
                    f"Application {application.application_number} rejected | "
                    f"Reason: {reason} | "
                    f"By: {rejected_by if rejected_by else 'system'}"
                )
            
            return success, message
            
        except Exception as e:
            logger.error(f"Error rejecting application: {e}", exc_info=True)
            return False, f"Error rejecting application: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def cancel_application(application, reason, cancelled_by=None):
        """
        Cancel loan application.
        
        Args:
            application: LoanApplication instance
            reason (str): Reason for cancellation
            cancelled_by: User who cancelled the application
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if application.status in ['APPROVED', 'DISBURSED']:
            return False, f"Cannot cancel application with status: {application.get_status_display()}"
        
        try:
            application.status = 'CANCELLED'
            if reason:
                application.notes = f"{application.notes or ''}\nCancellation: {reason}".strip()
            application.save(update_fields=['status', 'notes', 'updated_at'])
            
            logger.info(
                f"Application {application.application_number} cancelled | "
                f"Reason: {reason} | "
                f"By: {cancelled_by if cancelled_by else 'member'}"
            )
            
            return True, "Application cancelled successfully"
            
        except Exception as e:
            logger.error(f"Error cancelling application: {e}", exc_info=True)
            return False, f"Error cancelling application: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def add_guarantor(application, guarantor_member, guarantee_amount, relationship=None):
        """
        Add a guarantor to loan application.
        
        Args:
            application: LoanApplication instance
            guarantor_member: Member acting as guarantor
            guarantee_amount (Decimal): Amount being guaranteed
            relationship (str, optional): Relationship to applicant
        
        Returns:
            tuple: (success: bool, guarantor_or_error_message)
        """
        # Validate guarantor is not the applicant
        if guarantor_member == application.member:
            return False, "Guarantor cannot be the loan applicant"
        
        # Check if guarantor already exists
        if application.guarantors.filter(guarantor=guarantor_member).exists():
            return False, "This member is already a guarantor for this application"
        
        try:
            guarantor = LoanGuarantor.objects.create(
                loan_application=application,
                guarantor=guarantor_member,
                guarantee_amount=guarantee_amount,
                relationship=relationship,
                status='PENDING'
            )
            
            logger.info(
                f"Guarantor added: {guarantor_member.get_full_name()} | "
                f"Application: {application.application_number} | "
                f"Amount: {guarantee_amount}"
            )
            
            return True, guarantor
            
        except Exception as e:
            logger.error(f"Error adding guarantor: {e}", exc_info=True)
            return False, f"Error adding guarantor: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def add_collateral(application, collateral_type, description, estimated_value,
                      valuation_date, owner_name, **kwargs):
        """
        Add collateral to loan application.
        
        Args:
            application: LoanApplication instance
            collateral_type (str): Type of collateral
            description (str): Description of collateral
            estimated_value (Decimal): Estimated value
            valuation_date (date): Valuation date
            owner_name (str): Owner of the collateral
            **kwargs: Additional collateral fields
        
        Returns:
            tuple: (success: bool, collateral_or_error_message)
        """
        try:
            collateral = LoanCollateral.objects.create(
                loan_application=application,
                collateral_type=collateral_type,
                description=description,
                estimated_value=estimated_value,
                valuation_date=valuation_date,
                owner_name=owner_name,
                **kwargs
            )
            
            logger.info(
                f"Collateral added: {collateral_type} | "
                f"Application: {application.application_number} | "
                f"Value: {estimated_value}"
            )
            
            return True, collateral
            
        except Exception as e:
            logger.error(f"Error adding collateral: {e}", exc_info=True)
            return False, f"Error adding collateral: {str(e)}"


# =============================================================================
# LOAN SERVICES
# =============================================================================

class LoanService:
    """Handle loan disbursement, management, and operations"""
    
    @staticmethod
    @transaction.atomic
    def disburse_loan(application, disbursement_date=None, disbursement_method=None,
                     disbursement_reference=None, disbursed_by=None):
        """
        Disburse approved loan.
        
        Creates the loan record and generates repayment schedule.
        
        Args:
            application: Approved LoanApplication instance
            disbursement_date (date, optional): Date of disbursement
            disbursement_method: PaymentMethod instance
            disbursement_reference (str, optional): External reference
            disbursed_by: User who disbursed the loan
        
        Returns:
            tuple: (success: bool, loan_or_error_message)
        """
        # Validate application is approved
        if application.status != 'APPROVED':
            return False, "Only approved applications can be disbursed"
        
        # Check if already disbursed
        if hasattr(application, 'approved_loan'):
            return False, "This application has already been disbursed"
        
        try:
            # Use approved amounts or defaults
            principal = application.approved_amount or application.amount_requested
            term = application.approved_term or application.term_months
            rate = application.approved_interest_rate or application.loan_product.interest_rate
            
            # Calculate interest based on product type
            if application.loan_product.interest_type == 'FLAT':
                total_interest = calculate_flat_interest(principal, rate, term)
            else:
                total_interest = calculate_reducing_balance_interest(principal, rate, term)
            
            # Calculate total fees
            total_fees = application.total_fees
            
            # Calculate total payable
            total_payable = principal + total_interest + total_fees
            
            # Calculate dates
            disb_date = disbursement_date or timezone.now().date()
            grace_days = application.loan_product.grace_period
            first_payment_date = disb_date + timedelta(days=grace_days)
            
            # Calculate expected end date based on payment frequency
            from .utils import calculate_next_payment_date
            expected_end = first_payment_date
            for _ in range(term - 1):
                expected_end = calculate_next_payment_date(
                    expected_end,
                    application.loan_product.repayment_cycle
                )
            
            # Create loan (number auto-generated by signal)
            loan = Loan.objects.create(
                member=application.member,
                loan_product=application.loan_product,
                application=application,
                principal_amount=principal,
                interest_rate=rate,
                term_months=term,
                payment_frequency=application.loan_product.repayment_cycle,
                disbursement_date=disb_date,
                first_payment_date=first_payment_date,
                expected_end_date=expected_end,
                status='ACTIVE',
                total_interest=total_interest,
                total_fees=total_fees,
                total_payable=total_payable,
                disbursement_method=disbursement_method,
                disbursement_reference=disbursement_reference
            )
            
            # Schedule will be auto-generated by signal
            
            logger.info(
                f"Loan disbursed: {loan.loan_number} | "
                f"Application: {application.application_number} | "
                f"Principal: {principal} | "
                f"Term: {term} months | "
                f"By: {disbursed_by if disbursed_by else 'system'}"
            )
            
            return True, loan
            
        except Exception as e:
            logger.error(f"Error disbursing loan: {e}", exc_info=True)
            return False, f"Error disbursing loan: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def write_off_loan(loan, reason, written_off_by=None):
        """
        Write off a defaulted loan.
        
        Args:
            loan: Loan instance
            reason (str): Reason for write-off
            written_off_by: User who wrote off the loan
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if loan.status not in ['ACTIVE', 'DEFAULTED']:
            return False, f"Cannot write off loan with status: {loan.get_status_display()}"
        
        try:
            loan.status = 'WRITTEN_OFF'
            if reason:
                loan.notes = f"{loan.notes or ''}\nWrite-off: {reason}".strip()
            loan.save(update_fields=['status', 'notes', 'updated_at'])
            
            logger.warning(
                f"Loan written off: {loan.loan_number} | "
                f"Outstanding: {loan.outstanding_total} | "
                f"Reason: {reason} | "
                f"By: {written_off_by if written_off_by else 'system'}"
            )
            
            return True, f"Loan {loan.loan_number} written off successfully"
            
        except Exception as e:
            logger.error(f"Error writing off loan: {e}", exc_info=True)
            return False, f"Error writing off loan: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def mark_as_defaulted(loan, reason, marked_by=None):
        """
        Mark loan as defaulted.
        
        Args:
            loan: Loan instance
            reason (str): Reason for default
            marked_by: User who marked as defaulted
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if loan.status != 'ACTIVE':
            return False, "Only active loans can be marked as defaulted"
        
        try:
            loan.status = 'DEFAULTED'
            if reason:
                loan.notes = f"{loan.notes or ''}\nDefaulted: {reason}".strip()
            loan.save(update_fields=['status', 'notes', 'updated_at'])
            
            logger.warning(
                f"Loan marked as defaulted: {loan.loan_number} | "
                f"Days in arrears: {loan.days_in_arrears} | "
                f"Outstanding: {loan.outstanding_total} | "
                f"Reason: {reason}"
            )
            
            return True, f"Loan {loan.loan_number} marked as defaulted"
            
        except Exception as e:
            logger.error(f"Error marking loan as defaulted: {e}", exc_info=True)
            return False, f"Error marking loan as defaulted: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def suspend_loan(loan, reason, suspended_by=None):
        """
        Suspend loan (pause interest/penalties).
        
        Args:
            loan: Loan instance
            reason (str): Reason for suspension
            suspended_by: User who suspended the loan
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if loan.status != 'ACTIVE':
            return False, "Only active loans can be suspended"
        
        try:
            loan.status = 'SUSPENDED'
            if reason:
                loan.notes = f"{loan.notes or ''}\nSuspended: {reason}".strip()
            loan.save(update_fields=['status', 'notes', 'updated_at'])
            
            logger.info(
                f"Loan suspended: {loan.loan_number} | "
                f"Reason: {reason} | "
                f"By: {suspended_by if suspended_by else 'system'}"
            )
            
            return True, f"Loan {loan.loan_number} suspended successfully"
            
        except Exception as e:
            logger.error(f"Error suspending loan: {e}", exc_info=True)
            return False, f"Error suspending loan: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def reactivate_loan(loan, reactivated_by=None):
        """
        Reactivate suspended loan.
        
        Args:
            loan: Loan instance
            reactivated_by: User who reactivated the loan
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if loan.status != 'SUSPENDED':
            return False, "Only suspended loans can be reactivated"
        
        try:
            loan.status = 'ACTIVE'
            loan.save(update_fields=['status', 'updated_at'])
            
            logger.info(
                f"Loan reactivated: {loan.loan_number} | "
                f"By: {reactivated_by if reactivated_by else 'system'}"
            )
            
            return True, f"Loan {loan.loan_number} reactivated successfully"
            
        except Exception as e:
            logger.error(f"Error reactivating loan: {e}", exc_info=True)
            return False, f"Error reactivating loan: {str(e)}"
    
    @staticmethod
    def calculate_early_settlement(loan):
        """
        Calculate amount required for early settlement.
        
        Args:
            loan: Loan instance
        
        Returns:
            dict: Settlement details
                {
                    'outstanding_principal': Decimal,
                    'outstanding_interest': Decimal,
                    'outstanding_penalties': Decimal,
                    'outstanding_fees': Decimal,
                    'early_repayment_penalty': Decimal,
                    'total_settlement': Decimal
                }
        """
        try:
            # Calculate early repayment penalty if applicable
            penalty = Decimal('0.00')
            if loan.loan_product.early_repayment_fee > 0:
                penalty = calculate_early_repayment_penalty(
                    loan.outstanding_principal,
                    loan.loan_product.early_repayment_fee
                )
            
            # Calculate total settlement amount
            total_settlement = (
                loan.outstanding_principal +
                loan.outstanding_interest +
                loan.outstanding_penalties +
                loan.outstanding_fees +
                penalty
            )
            
            return {
                'outstanding_principal': loan.outstanding_principal,
                'outstanding_interest': loan.outstanding_interest,
                'outstanding_penalties': loan.outstanding_penalties,
                'outstanding_fees': loan.outstanding_fees,
                'early_repayment_penalty': penalty,
                'total_settlement': total_settlement
            }
            
        except Exception as e:
            logger.error(f"Error calculating early settlement: {e}")
            return {
                'outstanding_principal': Decimal('0.00'),
                'outstanding_interest': Decimal('0.00'),
                'outstanding_penalties': Decimal('0.00'),
                'outstanding_fees': Decimal('0.00'),
                'early_repayment_penalty': Decimal('0.00'),
                'total_settlement': Decimal('0.00')
            }
    
    @staticmethod
    @transaction.atomic
    def restructure_loan(loan, new_term_months=None, new_interest_rate=None,
                        reason=None, restructured_by=None):
        """
        Restructure existing loan (change term or interest rate).
        
        Args:
            loan: Loan instance
            new_term_months (int, optional): New loan term
            new_interest_rate (Decimal, optional): New interest rate
            reason (str, optional): Reason for restructuring
            restructured_by: User who restructured the loan
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if loan.status not in ['ACTIVE', 'DEFAULTED']:
            return False, f"Cannot restructure loan with status: {loan.get_status_display()}"
        
        if not new_term_months and not new_interest_rate:
            return False, "Either new term or new interest rate must be provided"
        
        try:
            # Update loan parameters
            if new_term_months:
                loan.term_months = new_term_months
            
            if new_interest_rate:
                loan.interest_rate = new_interest_rate
            
            # Recalculate interest
            if loan.loan_product.interest_type == 'FLAT':
                loan.total_interest = calculate_flat_interest(
                    loan.outstanding_principal,
                    loan.interest_rate,
                    loan.term_months
                )
            else:
                loan.total_interest = calculate_reducing_balance_interest(
                    loan.outstanding_principal,
                    loan.interest_rate,
                    loan.term_months
                )
            
            # Recalculate total payable
            loan.total_payable = (
                loan.outstanding_principal +
                loan.total_interest +
                loan.outstanding_fees
            )
            
            # Update status to RESTRUCTURED
            loan.status = 'RESTRUCTURED'
            
            # Add note
            if reason:
                loan.notes = f"{loan.notes or ''}\nRestructured: {reason}".strip()
            
            loan.save()
            
            # Regenerate schedule
            # Delete old schedule
            loan.schedule.all().delete()
            
            # Generate new schedule
            schedule_items = generate_loan_schedule(
                principal=loan.outstanding_principal,
                rate=loan.interest_rate,
                term_months=loan.term_months,
                start_date=timezone.now().date(),
                payment_frequency=loan.payment_frequency,
                interest_type=loan.loan_product.interest_type
            )
            
            # Create new schedule
            schedule_records = []
            for item in schedule_items:
                schedule_records.append(
                    LoanSchedule(
                        loan=loan,
                        installment_number=item['installment_number'],
                        due_date=item['due_date'],
                        principal_amount=item['principal'],
                        interest_amount=item['interest'],
                        total_amount=item['total'],
                        balance=item['balance']
                    )
                )
            
            LoanSchedule.objects.bulk_create(schedule_records)
            
            logger.info(
                f"Loan restructured: {loan.loan_number} | "
                f"New term: {loan.term_months} months | "
                f"New rate: {loan.interest_rate}% | "
                f"By: {restructured_by if restructured_by else 'system'}"
            )
            
            return True, f"Loan {loan.loan_number} restructured successfully"
            
        except Exception as e:
            logger.error(f"Error restructuring loan: {e}", exc_info=True)
            return False, f"Error restructuring loan: {str(e)}"


# =============================================================================
# PAYMENT SERVICES
# =============================================================================

class LoanPaymentService:
    """Handle loan payment processing"""
    
    @staticmethod
    @transaction.atomic
    def process_payment(loan, payment_amount, payment_date, payment_method,
                       reference_number=None, notes=None, processed_by=None):
        """
        Process a loan payment.
        
        Payment is automatically allocated to fees → penalties → interest → principal.
        Loan balances and schedule are automatically updated by signals.
        
        Args:
            loan: Loan instance
            payment_amount (Decimal): Payment amount
            payment_date (date): Payment date
            payment_method (str): Payment method
            reference_number (str, optional): External reference
            notes (str, optional): Payment notes
            processed_by: User who processed the payment
        
        Returns:
            tuple: (success: bool, payment_or_error_message)
        """
        # Validate loan can accept payments
        if loan.status not in ['ACTIVE', 'DEFAULTED', 'RESTRUCTURED']:
            return False, f"Cannot process payment for loan with status: {loan.get_status_display()}"
        
        # Validate payment amount
        try:
            amount = Decimal(str(payment_amount))
            if amount <= Decimal('0.00'):
                return False, "Payment amount must be greater than zero"
        except (ValueError, TypeError):
            return False, "Invalid payment amount"
        
        try:
            # Payment allocation happens automatically in signal
            # Just create the payment
            payment = LoanPayment.objects.create(
                loan=loan,
                payment_date=payment_date,
                amount=amount,
                payment_method=payment_method,
                reference_number=reference_number,
                notes=notes
            )
            
            logger.info(
                f"Payment processed: {payment.payment_number} | "
                f"Loan: {loan.loan_number} | "
                f"Amount: {amount} | "
                f"Principal: {payment.principal_amount} | "
                f"Interest: {payment.interest_amount} | "
                f"By: {processed_by if processed_by else 'system'}"
            )
            
            return True, payment
            
        except Exception as e:
            logger.error(f"Error processing payment: {e}", exc_info=True)
            return False, f"Error processing payment: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def reverse_payment(payment, reason, reversed_by=None):
        """
        Reverse a loan payment.
        
        Args:
            payment: LoanPayment instance
            reason (str): Reason for reversal
            reversed_by: User who reversed the payment
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if payment.is_reversed:
            return False, "Payment is already reversed"
        
        if not reason:
            return False, "Reversal reason is required"
        
        try:
            # Use model method
            success, message = payment.reverse(reason)
            
            if success:
                # Update reversed_by
                payment.reversed_by_id = str(reversed_by.id) if reversed_by else None
                payment.save(update_fields=['reversed_by_id'])
                
                logger.warning(
                    f"Payment reversed: {payment.payment_number} | "
                    f"Loan: {payment.loan.loan_number} | "
                    f"Amount: {payment.amount} | "
                    f"Reason: {reason} | "
                    f"By: {reversed_by if reversed_by else 'system'}"
                )
            
            return success, message
            
        except Exception as e:
            logger.error(f"Error reversing payment: {e}", exc_info=True)
            return False, f"Error reversing payment: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def early_settlement(loan, payment_date, payment_method, reference_number=None,
                        processed_by=None):
        """
        Process early settlement (full loan payoff).
        
        Args:
            loan: Loan instance
            payment_date (date): Settlement date
            payment_method (str): Payment method
            reference_number (str, optional): External reference
            processed_by: User who processed the settlement
        
        Returns:
            tuple: (success: bool, payment_or_error_message)
        """
        # Calculate settlement amount
        settlement_details = LoanService.calculate_early_settlement(loan)
        total_settlement = settlement_details['total_settlement']
        
        # Process payment
        success, result = LoanPaymentService.process_payment(
            loan=loan,
            payment_amount=total_settlement,
            payment_date=payment_date,
            payment_method=payment_method,
            reference_number=reference_number,
            notes=f"Early settlement payment. Penalty: {settlement_details['early_repayment_penalty']}",
            processed_by=processed_by
        )
        
        if success:
            logger.info(
                f"Loan settled early: {loan.loan_number} | "
                f"Settlement amount: {total_settlement} | "
                f"Penalty: {settlement_details['early_repayment_penalty']}"
            )
        
        return success, result


# =============================================================================
# PENALTY AND INTEREST SERVICES
# =============================================================================

class LoanPenaltyService:
    """Handle penalty calculations and application"""
    
    @staticmethod
    @transaction.atomic
    def apply_late_payment_penalties(as_of_date=None):
        """
        Apply late payment penalties to overdue loans.
        
        Args:
            as_of_date (date, optional): Date to calculate penalties as of
        
        Returns:
            dict: Results summary
                {
                    'processed': int,
                    'total_penalties': Decimal,
                    'errors': list
                }
        """
        calculation_date = as_of_date or timezone.now().date()
        
        # Get overdue loans
        overdue_loans = Loan.objects.filter(
            status='ACTIVE',
            days_in_arrears__gt=0
        )
        
        results = {
            'processed': 0,
            'total_penalties': Decimal('0.00'),
            'errors': []
        }
        
        for loan in overdue_loans:
            try:
                # Check if penalty grace period has passed
                if loan.days_in_arrears <= loan.loan_product.penalty_grace_period:
                    continue
                
                # Get overdue schedule items
                overdue_installments = loan.schedule.filter(
                    status='OVERDUE',
                    balance__gt=0
                )
                
                for installment in overdue_installments:
                    # Calculate days overdue
                    days_overdue = (calculation_date - installment.due_date).days
                    
                    if days_overdue <= 0:
                        continue
                    
                    # Calculate penalty
                    penalty = calculate_late_payment_penalty(
                        overdue_amount=installment.balance,
                        penalty_rate=loan.loan_product.penalty_rate,
                        days_overdue=days_overdue
                    )
                    
                    if penalty > Decimal('0.00'):
                        # Add to loan's outstanding penalties
                        loan.outstanding_penalties += penalty
                        results['total_penalties'] += penalty
                
                loan.save()
                results['processed'] += 1
                
                logger.debug(
                    f"Applied penalties to loan {loan.loan_number}: {results['total_penalties']}"
                )
                
            except Exception as e:
                error_msg = f"Error applying penalties to loan {loan.loan_number}: {str(e)}"
                logger.error(error_msg)
                results['errors'].append(error_msg)
        
        logger.info(
            f"Applied late payment penalties: {results['processed']} loans processed, "
            f"Total penalties: {results['total_penalties']}"
        )
        
        return results
    
    @staticmethod
    @transaction.atomic
    def waive_penalties(loan, amount, reason, waived_by=None):
        """
        Waive loan penalties.
        
        Args:
            loan: Loan instance
            amount (Decimal): Amount to waive
            reason (str): Reason for waiver
            waived_by: User who waived the penalties
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if not reason:
            return False, "Waiver reason is required"
        
        try:
            waive_amount = Decimal(str(amount))
            
            if waive_amount <= Decimal('0.00'):
                return False, "Waiver amount must be greater than zero"
            
            if waive_amount > loan.outstanding_penalties:
                return False, f"Waiver amount exceeds outstanding penalties of {loan.outstanding_penalties}"
            
            # Reduce outstanding penalties
            loan.outstanding_penalties -= waive_amount
            loan.notes = f"{loan.notes or ''}\nPenalty waiver: {waive_amount} - {reason}".strip()
            loan.save()
            
            logger.info(
                f"Penalties waived: {loan.loan_number} | "
                f"Amount: {waive_amount} | "
                f"Reason: {reason} | "
                f"By: {waived_by if waived_by else 'system'}"
            )
            
            return True, f"Penalties of {waive_amount} waived successfully"
            
        except Exception as e:
            logger.error(f"Error waiving penalties: {e}", exc_info=True)
            return False, f"Error waiving penalties: {str(e)}"


# =============================================================================
# BULK OPERATIONS
# =============================================================================

class LoanBulkOperations:
    """Handle bulk loan operations"""
    
    @staticmethod
    def update_arrears_status(as_of_date=None):
        """
        Update days in arrears for all active loans.
        
        Args:
            as_of_date (date, optional): Date to calculate as of
        
        Returns:
            dict: Results summary
        """
        calculation_date = as_of_date or timezone.now().date()
        
        active_loans = Loan.objects.filter(status='ACTIVE')
        
        results = {
            'processed': 0,
            'overdue': 0,
            'current': 0,
            'errors': []
        }
        
        for loan in active_loans:
            try:
                # Check if overdue
                is_overdue, days = is_loan_overdue(loan.next_payment_date)
                
                if is_overdue:
                    loan.days_in_arrears = days
                    results['overdue'] += 1
                else:
                    loan.days_in_arrears = 0
                    results['current'] += 1
                
                loan.save(update_fields=['days_in_arrears', 'updated_at'])
                results['processed'] += 1
                
            except Exception as e:
                error_msg = f"Error updating arrears for loan {loan.loan_number}: {str(e)}"
                logger.error(error_msg)
                results['errors'].append(error_msg)
        
        logger.info(
            f"Updated arrears status: {results['processed']} loans processed, "
            f"{results['overdue']} overdue, {results['current']} current"
        )
        
        return results
    
    @staticmethod
    @transaction.atomic
    def mark_overdue_schedule_items(as_of_date=None):
        """
        Mark schedule installments as overdue.
        
        Args:
            as_of_date (date, optional): Date to check as of
        
        Returns:
            int: Number of installments marked as overdue
        """
        calculation_date = as_of_date or timezone.now().date()
        
        # Get pending installments past due date
        overdue_count = LoanSchedule.objects.filter(
            status='PENDING',
            due_date__lt=calculation_date,
            balance__gt=0
        ).update(status='OVERDUE')
        
        logger.info(f"Marked {overdue_count} schedule installments as overdue")
        
        return overdue_count
