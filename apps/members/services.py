# members/services.py

"""
Members Business Logic Services

Contains complex business logic that shouldn't be in views or models:
- Member registration and onboarding
- KYC verification workflows
- Member status management
- Credit score updates
- Group membership management
- Payment method management
- Next of kin management
- Bulk operations

WHY SERVICES.PY?
1. Separation of Concerns: Complex business logic separate from views
2. Reusability: Can be called from views, management commands, celery tasks
3. Testing: Easier to test business logic in isolation
4. Transaction Management: Handle complex multi-step operations
5. Clear API: Well-defined functions for each business operation
"""

from django.db import transaction
from django.utils import timezone
from django.db.models import Sum, Count, Q
from decimal import Decimal
import logging

from .models import (
    Member,
    MemberPaymentMethod,
    NextOfKin,
    MemberAdditionalContact,
    MemberGroup,
    GroupMembership,
)

from .utils import (
    calculate_credit_score,
    calculate_risk_rating,
    calculate_age,
    validate_minimum_age,
    validate_loan_eligibility,
    validate_group_membership,
)

logger = logging.getLogger(__name__)


# =============================================================================
# MEMBER SERVICES
# =============================================================================

class MemberService:
    """Handle member registration and management"""
    
    @staticmethod
    @transaction.atomic
    def register_member(member_data, created_by=None):
        """
        Register a new member.
        
        Args:
            member_data (dict): Member information
                {
                    'id_number': str,
                    'id_type': str,
                    'first_name': str,
                    'last_name': str,
                    'middle_name': str (optional),
                    'date_of_birth': date,
                    'gender': str,
                    'phone_primary': str,
                    'personal_email': str (optional),
                    'physical_address': str,
                    'employment_status': str,
                    'monthly_income': Decimal (optional),
                    'member_category': str (optional),
                    'membership_plan': str (optional),
                    ... (other member fields)
                }
            created_by: User who created the member
        
        Returns:
            tuple: (success: bool, member_or_error_message)
        """
        # Validate minimum age
        is_valid, message, age = validate_minimum_age(member_data['date_of_birth'])
        if not is_valid:
            return False, message
        
        # Check for duplicate ID number
        if Member.objects.filter(id_number=member_data['id_number']).exists():
            return False, f"Member with ID number {member_data['id_number']} already exists"
        
        try:
            # Set default membership date
            if 'membership_date' not in member_data:
                member_data['membership_date'] = timezone.now().date()
            
            # Set default status
            if 'status' not in member_data:
                member_data['status'] = 'PENDING_APPROVAL'
            
            # Set default employment status if not provided
            if 'employment_status' not in member_data:
                member_data['employment_status'] = 'UNEMPLOYED'
            
            # Set default marital status if not provided
            if 'marital_status' not in member_data:
                member_data['marital_status'] = 'SINGLE'
            
            # Create member (member_number and credit_score auto-generated by signals)
            member = Member.objects.create(**member_data)
            
            logger.info(
                f"Member registered: {member.member_number} | "
                f"Name: {member.get_full_name()} | "
                f"By: {created_by if created_by else 'self-registration'}"
            )
            
            return True, member
            
        except Exception as e:
            logger.error(f"Error registering member: {e}", exc_info=True)
            return False, f"Error registering member: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def approve_member(member, approved_by=None):
        """
        Approve pending member.
        
        Args:
            member: Member instance
            approved_by: User who approved the member
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if member.status != 'PENDING_APPROVAL':
            return False, f"Cannot approve member with status: {member.get_status_display()}"
        
        try:
            # Use model method
            member.activate()
            
            logger.info(
                f"Member approved: {member.member_number} | "
                f"By: {approved_by if approved_by else 'system'}"
            )
            
            return True, f"Member {member.member_number} approved successfully"
            
        except Exception as e:
            logger.error(f"Error approving member: {e}", exc_info=True)
            return False, f"Error approving member: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def suspend_member(member, reason, suspended_by=None):
        """
        Suspend member.
        
        Args:
            member: Member instance
            reason (str): Suspension reason
            suspended_by: User who suspended the member
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if member.status not in ['ACTIVE', 'DORMANT']:
            return False, f"Cannot suspend member with status: {member.get_status_display()}"
        
        if not reason:
            return False, "Suspension reason is required"
        
        try:
            # Use model method
            member.suspend(reason)
            
            logger.info(
                f"Member suspended: {member.member_number} | "
                f"Reason: {reason} | "
                f"By: {suspended_by if suspended_by else 'system'}"
            )
            
            return True, f"Member {member.member_number} suspended successfully"
            
        except Exception as e:
            logger.error(f"Error suspending member: {e}", exc_info=True)
            return False, f"Error suspending member: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def reactivate_member(member, reactivated_by=None):
        """
        Reactivate suspended member.
        
        Args:
            member: Member instance
            reactivated_by: User who reactivated the member
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if member.status not in ['SUSPENDED', 'DORMANT']:
            return False, f"Cannot reactivate member with status: {member.get_status_display()}"
        
        try:
            # Use model method
            member.activate()
            
            logger.info(
                f"Member reactivated: {member.member_number} | "
                f"By: {reactivated_by if reactivated_by else 'system'}"
            )
            
            return True, f"Member {member.member_number} reactivated successfully"
            
        except Exception as e:
            logger.error(f"Error reactivating member: {e}", exc_info=True)
            return False, f"Error reactivating member: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def update_member_profile(member, update_data, updated_by=None):
        """
        Update member profile information.
        
        Args:
            member: Member instance
            update_data (dict): Fields to update
            updated_by: User who updated the profile
        
        Returns:
            tuple: (success: bool, message: str)
        """
        try:
            # Fields that should not be updated through this method
            protected_fields = ['member_number', 'id_number', 'created_at', 'credit_score']
            
            for field, value in update_data.items():
                if field not in protected_fields:
                    setattr(member, field, value)
            
            member.save()
            
            logger.info(
                f"Member profile updated: {member.member_number} | "
                f"Fields: {list(update_data.keys())} | "
                f"By: {updated_by if updated_by else 'self'}"
            )
            
            return True, "Profile updated successfully"
            
        except Exception as e:
            logger.error(f"Error updating member profile: {e}", exc_info=True)
            return False, f"Error updating profile: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def update_credit_score(member):
        """
        Recalculate and update member's credit score.
        
        Args:
            member: Member instance
        
        Returns:
            tuple: (success: bool, new_credit_score: int, message: str)
        """
        try:
            # Get member's financial data
            total_savings = member.get_total_savings()
            total_shares = member.get_total_shares()
            active_loans = member.get_active_loans_count()
            
            # Get loan payment history
            from loans.models import Loan
            loans = Loan.objects.filter(member=member, status='PAID')
            total_loans = loans.count()
            
            # Count defaults (loans that went to DEFAULTED status)
            defaults = Loan.objects.filter(
                member=member,
                status='DEFAULTED'
            ).count()
            
            # Calculate payment history score (simplified)
            if total_loans > 0:
                payment_score = max(0, 100 - (defaults * 20))
            else:
                payment_score = 50  # Neutral score for no history
            
            # Prepare data for credit score calculation
            member_data = {
                'age': member.age,
                'employment_status': member.employment_status,
                'monthly_income': member.monthly_income or Decimal('0'),
                'membership_years': member.membership_duration_years,
                'kyc_verified': member.kyc_status == 'VERIFIED',
                'savings_balance': total_savings,
                'loans_count': total_loans,
                'loan_defaults': defaults,
                'payment_history_score': payment_score
            }
            
            # Calculate new credit score
            new_score = calculate_credit_score(member_data)
            
            # Update member
            old_score = member.credit_score
            member.credit_score = new_score
            member.save(update_fields=['credit_score', 'updated_at'])
            
            # Risk rating will be auto-updated by signal
            
            logger.info(
                f"Credit score updated: {member.member_number} | "
                f"{old_score} → {new_score}"
            )
            
            return True, new_score, f"Credit score updated from {old_score} to {new_score}"
            
        except Exception as e:
            logger.error(f"Error updating credit score: {e}", exc_info=True)
            return False, member.credit_score, f"Error updating credit score: {str(e)}"


# =============================================================================
# KYC SERVICES
# =============================================================================

class KYCService:
    """Handle KYC verification workflows"""
    
    @staticmethod
    @transaction.atomic
    def start_kyc_verification(member, verified_by=None):
        """
        Start KYC verification process.
        
        Args:
            member: Member instance
            verified_by: User who started verification
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if member.kyc_status == 'VERIFIED':
            return False, "Member KYC is already verified"
        
        try:
            member.kyc_status = 'IN_PROGRESS'
            member.save(update_fields=['kyc_status', 'updated_at'])
            
            logger.info(
                f"KYC verification started: {member.member_number} | "
                f"By: {verified_by if verified_by else 'system'}"
            )
            
            return True, "KYC verification started"
            
        except Exception as e:
            logger.error(f"Error starting KYC verification: {e}", exc_info=True)
            return False, f"Error starting KYC verification: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def verify_kyc(member, expiry_years=2, verified_by=None):
        """
        Complete KYC verification.
        
        Args:
            member: Member instance
            expiry_years (int): Years until KYC expires
            verified_by: User who verified KYC
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if member.kyc_status == 'VERIFIED':
            return False, "Member KYC is already verified"
        
        try:
            now = timezone.now()
            
            member.kyc_status = 'VERIFIED'
            member.kyc_verified_date = now
            member.kyc_expiry_date = now + timezone.timedelta(days=expiry_years * 365)
            member.save(update_fields=[
                'kyc_status', 'kyc_verified_date', 'kyc_expiry_date', 'updated_at'
            ])
            
            logger.info(
                f"KYC verified: {member.member_number} | "
                f"Expiry: {member.kyc_expiry_date.date()} | "
                f"By: {verified_by if verified_by else 'system'}"
            )
            
            return True, f"KYC verified successfully. Valid until {member.kyc_expiry_date.date()}"
            
        except Exception as e:
            logger.error(f"Error verifying KYC: {e}", exc_info=True)
            return False, f"Error verifying KYC: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def reject_kyc(member, reason, rejected_by=None):
        """
        Reject KYC verification.
        
        Args:
            member: Member instance
            reason (str): Rejection reason
            rejected_by: User who rejected KYC
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if not reason:
            return False, "Rejection reason is required"
        
        try:
            member.kyc_status = 'REJECTED'
            member.kyc_notes = f"{member.kyc_notes or ''}\nRejected: {reason}".strip()
            member.save(update_fields=['kyc_status', 'kyc_notes', 'updated_at'])
            
            logger.info(
                f"KYC rejected: {member.member_number} | "
                f"Reason: {reason} | "
                f"By: {rejected_by if rejected_by else 'system'}"
            )
            
            return True, "KYC verification rejected"
            
        except Exception as e:
            logger.error(f"Error rejecting KYC: {e}", exc_info=True)
            return False, f"Error rejecting KYC: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def renew_kyc(member, expiry_years=2, renewed_by=None):
        """
        Renew expired KYC.
        
        Args:
            member: Member instance
            expiry_years (int): Years until new expiry
            renewed_by: User who renewed KYC
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if member.kyc_status not in ['VERIFIED', 'EXPIRED', 'REQUIRES_UPDATE']:
            return False, "KYC must be verified, expired, or require update to renew"
        
        try:
            now = timezone.now()
            
            member.kyc_status = 'VERIFIED'
            member.kyc_verified_date = now
            member.kyc_expiry_date = now + timezone.timedelta(days=expiry_years * 365)
            member.save(update_fields=[
                'kyc_status', 'kyc_verified_date', 'kyc_expiry_date', 'updated_at'
            ])
            
            logger.info(
                f"KYC renewed: {member.member_number} | "
                f"New expiry: {member.kyc_expiry_date.date()} | "
                f"By: {renewed_by if renewed_by else 'system'}"
            )
            
            return True, f"KYC renewed successfully. Valid until {member.kyc_expiry_date.date()}"
            
        except Exception as e:
            logger.error(f"Error renewing KYC: {e}", exc_info=True)
            return False, f"Error renewing KYC: {str(e)}"


# =============================================================================
# PAYMENT METHOD SERVICES
# =============================================================================

class PaymentMethodService:
    """Handle member payment method management"""
    
    @staticmethod
    @transaction.atomic
    def add_payment_method(member, method_type, provider, account_number,
                          account_name, is_primary=False, **kwargs):
        """
        Add payment method to member.
        
        Args:
            member: Member instance
            method_type (str): Payment method type
            provider (str): Provider/bank name
            account_number (str): Account/phone number
            account_name (str): Account name
            is_primary (bool): Set as primary method
            **kwargs: Additional fields
        
        Returns:
            tuple: (success: bool, payment_method_or_error_message)
        """
        try:
            # Create payment method
            payment_method = MemberPaymentMethod.objects.create(
                member=member,
                method_type=method_type,
                provider=provider,
                account_number=account_number,
                account_name=account_name,
                is_primary=is_primary,
                **kwargs
            )
            
            logger.info(
                f"Payment method added: {member.member_number} | "
                f"Type: {payment_method.get_method_type_display()} | "
                f"Provider: {provider}"
            )
            
            return True, payment_method
            
        except Exception as e:
            logger.error(f"Error adding payment method: {e}", exc_info=True)
            return False, f"Error adding payment method: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def verify_payment_method(payment_method, verified_by=None):
        """
        Verify payment method.
        
        Args:
            payment_method: MemberPaymentMethod instance
            verified_by: User who verified the method
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if payment_method.is_verified:
            return False, "Payment method is already verified"
        
        try:
            # Use model method
            payment_method.verify()
            
            logger.info(
                f"Payment method verified: {payment_method.member.member_number} | "
                f"Type: {payment_method.get_method_type_display()} | "
                f"By: {verified_by if verified_by else 'system'}"
            )
            
            return True, "Payment method verified successfully"
            
        except Exception as e:
            logger.error(f"Error verifying payment method: {e}", exc_info=True)
            return False, f"Error verifying payment method: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def set_primary_payment_method(payment_method):
        """
        Set payment method as primary.
        
        Args:
            payment_method: MemberPaymentMethod instance
        
        Returns:
            tuple: (success: bool, message: str)
        """
        try:
            # Use model method
            payment_method.make_primary()
            
            logger.info(
                f"Primary payment method updated: {payment_method.member.member_number} | "
                f"Type: {payment_method.get_method_type_display()}"
            )
            
            return True, "Primary payment method updated"
            
        except Exception as e:
            logger.error(f"Error setting primary payment method: {e}", exc_info=True)
            return False, f"Error setting primary payment method: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def remove_payment_method(payment_method, removed_by=None):
        """
        Remove payment method.
        
        Args:
            payment_method: MemberPaymentMethod instance
            removed_by: User who removed the method
        
        Returns:
            tuple: (success: bool, message: str)
        """
        # Check if this is the only payment method
        member = payment_method.member
        method_count = member.payment_methods.filter(is_active=True).count()
        
        if method_count <= 1:
            return False, "Cannot remove the only payment method"
        
        try:
            payment_method.is_active = False
            payment_method.save(update_fields=['is_active', 'updated_at'])
            
            logger.info(
                f"Payment method removed: {member.member_number} | "
                f"Type: {payment_method.get_method_type_display()} | "
                f"By: {removed_by if removed_by else 'member'}"
            )
            
            return True, "Payment method removed successfully"
            
        except Exception as e:
            logger.error(f"Error removing payment method: {e}", exc_info=True)
            return False, f"Error removing payment method: {str(e)}"


# =============================================================================
# NEXT OF KIN SERVICES
# =============================================================================

class NextOfKinService:
    """Handle next of kin management"""
    
    @staticmethod
    @transaction.atomic
    def add_next_of_kin(member, name, relation, contact, is_primary=False,
                       is_beneficiary=False, beneficiary_percentage=Decimal('0.00'),
                       **kwargs):
        """
        Add next of kin to member.
        
        Args:
            member: Member instance
            name (str): Full name
            relation (str): Relationship
            contact (str): Phone number
            is_primary (bool): Set as primary NOK
            is_beneficiary (bool): Set as beneficiary
            beneficiary_percentage (Decimal): Beneficiary percentage
            **kwargs: Additional fields
        
        Returns:
            tuple: (success: bool, next_of_kin_or_error_message)
        """
        try:
            # Create next of kin
            nok = NextOfKin.objects.create(
                member=member,
                name=name,
                relation=relation,
                contact=contact,
                is_primary=is_primary,
                is_beneficiary=is_beneficiary,
                beneficiary_percentage=beneficiary_percentage,
                **kwargs
            )
            
            logger.info(
                f"Next of kin added: {member.member_number} | "
                f"Name: {name} | "
                f"Relation: {nok.get_relation_display()}"
            )
            
            return True, nok
            
        except Exception as e:
            logger.error(f"Error adding next of kin: {e}", exc_info=True)
            return False, f"Error adding next of kin: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def update_next_of_kin(next_of_kin, update_data, updated_by=None):
        """
        Update next of kin information.
        
        Args:
            next_of_kin: NextOfKin instance
            update_data (dict): Fields to update
            updated_by: User who updated
        
        Returns:
            tuple: (success: bool, message: str)
        """
        try:
            for field, value in update_data.items():
                setattr(next_of_kin, field, value)
            
            next_of_kin.save()
            
            logger.info(
                f"Next of kin updated: {next_of_kin.member.member_number} | "
                f"Name: {next_of_kin.name} | "
                f"By: {updated_by if updated_by else 'member'}"
            )
            
            return True, "Next of kin updated successfully"
            
        except Exception as e:
            logger.error(f"Error updating next of kin: {e}", exc_info=True)
            return False, f"Error updating next of kin: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def remove_next_of_kin(next_of_kin, removed_by=None):
        """
        Remove next of kin.
        
        Args:
            next_of_kin: NextOfKin instance
            removed_by: User who removed
        
        Returns:
            tuple: (success: bool, message: str)
        """
        # Check if this is the only next of kin
        member = next_of_kin.member
        nok_count = member.next_of_kin.count()
        
        if nok_count <= 1:
            return False, "Member must have at least one next of kin"
        
        try:
            member_number = member.member_number
            nok_name = next_of_kin.name
            
            next_of_kin.delete()
            
            logger.info(
                f"Next of kin removed: {member_number} | "
                f"Name: {nok_name} | "
                f"By: {removed_by if removed_by else 'member'}"
            )
            
            return True, "Next of kin removed successfully"
            
        except Exception as e:
            logger.error(f"Error removing next of kin: {e}", exc_info=True)
            return False, f"Error removing next of kin: {str(e)}"


# =============================================================================
# GROUP MEMBERSHIP SERVICES
# =============================================================================

class GroupMembershipService:
    """Handle group membership operations"""
    
    @staticmethod
    @transaction.atomic
    def join_group(member, group, role='MEMBER', monthly_contribution=None):
        """
        Add member to group.
        
        Args:
            member: Member instance
            group: MemberGroup instance
            role (str): Member's role in group
            monthly_contribution (Decimal, optional): Monthly contribution
        
        Returns:
            tuple: (success: bool, membership_or_error_message)
        """
        # Validate membership
        member_data = {
            'status': member.status,
            'active_groups_count': member.member_groups.filter(
                groupmembership__is_active=True
            ).count()
        }
        
        group_data = {
            'is_active': group.is_active,
            'is_full': group.is_full,
            'current_members': group.member_count,
            'maximum_members': group.maximum_members
        }
        
        can_join, message = validate_group_membership(member_data, group_data)
        if not can_join:
            return False, message
        
        # Check if already a member
        if GroupMembership.objects.filter(member=member, group=group, is_active=True).exists():
            return False, "Member is already in this group"
        
        try:
            # Use group's minimum contribution if not specified
            contribution = monthly_contribution or group.minimum_contribution
            
            # Create membership
            membership = GroupMembership.objects.create(
                member=member,
                group=group,
                role=role,
                monthly_contribution=contribution,
                join_date=timezone.now().date(),
                is_active=True,
                status='ACTIVE'
            )
            
            logger.info(
                f"Member joined group: {member.member_number} | "
                f"Group: {group.name} | "
                f"Role: {membership.get_role_display()}"
            )
            
            return True, membership
            
        except Exception as e:
            logger.error(f"Error joining group: {e}", exc_info=True)
            return False, f"Error joining group: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def leave_group(membership, reason=None, left_by=None):
        """
        Remove member from group.
        
        Args:
            membership: GroupMembership instance
            reason (str, optional): Reason for leaving
            left_by: User who processed the leave
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if not membership.is_active:
            return False, "Membership is already inactive"
        
        try:
            # Use model method
            membership.leave_group(reason)
            
            logger.info(
                f"Member left group: {membership.member.member_number} | "
                f"Group: {membership.group.name} | "
                f"By: {left_by if left_by else 'member'}"
            )
            
            return True, "Member left group successfully"
            
        except Exception as e:
            logger.error(f"Error leaving group: {e}", exc_info=True)
            return False, f"Error leaving group: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def change_member_role(membership, new_role, changed_by=None):
        """
        Change member's role in group.
        
        Args:
            membership: GroupMembership instance
            new_role (str): New role
            changed_by: User who changed the role
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if not membership.is_active:
            return False, "Cannot change role for inactive membership"
        
        try:
            old_role = membership.role
            membership.role = new_role
            membership.save(update_fields=['role', 'updated_at'])
            
            logger.info(
                f"Group role changed: {membership.member.member_number} | "
                f"Group: {membership.group.name} | "
                f"{old_role} → {new_role} | "
                f"By: {changed_by if changed_by else 'admin'}"
            )
            
            return True, f"Role changed to {membership.get_role_display()}"
            
        except Exception as e:
            logger.error(f"Error changing role: {e}", exc_info=True)
            return False, f"Error changing role: {str(e)}"
    
    @staticmethod
    @transaction.atomic
    def record_group_contribution(membership, amount, contribution_date=None):
        """
        Record member's contribution to group.
        
        Args:
            membership: GroupMembership instance
            amount (Decimal): Contribution amount
            contribution_date (date, optional): Contribution date
        
        Returns:
            tuple: (success: bool, message: str)
        """
        if not membership.is_active:
            return False, "Cannot record contribution for inactive membership"
        
        try:
            # Update total contributions
            membership.total_contributions += amount
            membership.save(update_fields=['total_contributions', 'updated_at'])
            
            logger.info(
                f"Group contribution recorded: {membership.member.member_number} | "
                f"Group: {membership.group.name} | "
                f"Amount: {amount}"
            )
            
            return True, "Contribution recorded successfully"
            
        except Exception as e:
            logger.error(f"Error recording contribution: {e}", exc_info=True)
            return False, f"Error recording contribution: {str(e)}"


# =============================================================================
# BULK OPERATIONS
# =============================================================================

class MemberBulkOperations:
    """Handle bulk member operations"""
    
    @staticmethod
    def update_all_credit_scores():
        """
        Update credit scores for all active members.
        
        Returns:
            dict: Results summary
        """
        members = Member.objects.filter(status='ACTIVE')
        
        updated_count = 0
        errors = []
        
        for member in members:
            try:
                success, new_score, message = MemberService.update_credit_score(member)
                
                if success:
                    updated_count += 1
                else:
                    errors.append(f"{member.member_number}: {message}")
                    
            except Exception as e:
                error_msg = f"Error updating {member.member_number}: {str(e)}"
                logger.error(error_msg)
                errors.append(error_msg)
        
        logger.info(f"Updated credit scores for {updated_count} members")
        
        return {
            'success': updated_count > 0,
            'message': f'Updated {updated_count} credit scores',
            'updated': updated_count,
            'errors': errors
        }
    
    @staticmethod
    def mark_dormant_members(inactivity_months=6):
        """
        Mark members as dormant based on inactivity.
        
        Args:
            inactivity_months (int): Months of inactivity threshold
        
        Returns:
            dict: Results summary
        """
        from datetime import timedelta
        
        cutoff_date = timezone.now().date() - timedelta(days=inactivity_months * 30)
        
        # This is a simplified implementation
        # In real scenario, you'd check last transaction dates
        
        dormant_count = Member.objects.filter(
            status='ACTIVE',
            membership_date__lt=cutoff_date
        ).update(
            status='DORMANT',
            status_changed_date=timezone.now(),
            status_changed_reason=f'Marked dormant due to {inactivity_months} months inactivity'
        )
        
        logger.info(f"Marked {dormant_count} members as dormant")
        
        return {
            'success': True,
            'message': f'Marked {dormant_count} members as dormant',
            'marked': dormant_count
        }
    
    @staticmethod
    def update_expired_kyc():
        """
        Update KYC status for expired verifications.
        
        Returns:
            dict: Results summary
        """
        now = timezone.now()
        
        expired_count = Member.objects.filter(
            kyc_status='VERIFIED',
            kyc_expiry_date__lt=now
        ).update(
            kyc_status='EXPIRED'
        )
        
        logger.info(f"Updated {expired_count} expired KYC records")
        
        return {
            'success': True,
            'message': f'Updated {expired_count} expired KYC records',
            'updated': expired_count
        }

